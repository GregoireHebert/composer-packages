<?php

declare(strict_types=1);

namespace ComposerPackages;

use Composer\Package\CompletePackage;
use Composer\Package\PackageInterface;
use Composer\Package\Loader\ArrayLoader;

/**
 * This class is generated by drupol/composer-packages.
 *
 * This file is overwritten at every run of `composer install` or `composer update`.
 */
final class Types implements \Countable, \IteratorAggregate
{
    public const GENERATED_AT = {{ generatedAt }};
    public const ROOT_PACKAGE_NAME = '{{ rootPackageName }}';

    private const TYPES = {{ types | export }};

    /**
     * {@inheridoc}
     */
    public function count(): int
    {
        return count(self::TYPES);
    }

    /**
     * @param string $type
     *
     * @return \Generator
     *   A packages generator.
     */
    public static function get(string $type): \Generator
    {
        if (isset(self::TYPES[$type])) {
            yield from self::getPackages(self::TYPES[$type]);
        }
    }

{% for type, data in types %}
    /**
     * Get packages of type "{{ type }}".
     *
     * @return \Generator
     *   A packages generator.
     */
    public static function {{ type | camelize }}(): \Generator
    {
        yield from self::getPackages(self::TYPES['{{ type }}']);
    }

{% endfor %}
    /**
     * {@inheritdoc}
     */
    public function getIterator(): \Generator
    {
        foreach (array_keys(self::TYPES) as $type) {
            yield $type => iterator_to_array(self::getPackages(self::TYPES[$type]));
        }
    }

    /**
     * Convert an array of packages into an array of Composer package objects.
     *
     * @param array $packages
     *   The array of packages.
     *
     * @return \Generator
     *   A packages generator.
     */
    private static function getPackages(array $packages): \Generator
    {
        foreach ($packages as $package) {
            yield (new ArrayLoader())->load($package);
        }
    }
}
